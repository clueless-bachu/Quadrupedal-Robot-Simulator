// Generated by gencpp from file deeprl/State.msg
// DO NOT EDIT!


#ifndef DEEPRL_MESSAGE_STATE_H
#define DEEPRL_MESSAGE_STATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace deeprl
{
template <class ContainerAllocator>
struct State_
{
  typedef State_<ContainerAllocator> Type;

  State_()
    : header()
    , error_dist(0.0)
    , error_angle(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , dx(0.0)
    , dy(0.0)
    , dz(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , droll(0.0)
    , dpitch(0.0)
    , dyaw(0.0)
    , flj(0.0)
    , fltl(0.0)
    , flbl(0.0)
    , frj(0.0)
    , frtl(0.0)
    , frbl(0.0)
    , blj(0.0)
    , bltl(0.0)
    , blbl(0.0)
    , brj(0.0)
    , brtl(0.0)
    , brbl(0.0)
    , dflj(0.0)
    , dfltl(0.0)
    , dflbl(0.0)
    , dfrj(0.0)
    , dfrtl(0.0)
    , dfrbl(0.0)
    , dblj(0.0)
    , dbltl(0.0)
    , dblbl(0.0)
    , dbrj(0.0)
    , dbrtl(0.0)
    , dbrbl(0.0)  {
    }
  State_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , error_dist(0.0)
    , error_angle(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , dx(0.0)
    , dy(0.0)
    , dz(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , droll(0.0)
    , dpitch(0.0)
    , dyaw(0.0)
    , flj(0.0)
    , fltl(0.0)
    , flbl(0.0)
    , frj(0.0)
    , frtl(0.0)
    , frbl(0.0)
    , blj(0.0)
    , bltl(0.0)
    , blbl(0.0)
    , brj(0.0)
    , brtl(0.0)
    , brbl(0.0)
    , dflj(0.0)
    , dfltl(0.0)
    , dflbl(0.0)
    , dfrj(0.0)
    , dfrtl(0.0)
    , dfrbl(0.0)
    , dblj(0.0)
    , dbltl(0.0)
    , dblbl(0.0)
    , dbrj(0.0)
    , dbrtl(0.0)
    , dbrbl(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _error_dist_type;
  _error_dist_type error_dist;

   typedef double _error_angle_type;
  _error_angle_type error_angle;

   typedef double _x_type;
  _x_type x;

   typedef double _y_type;
  _y_type y;

   typedef double _z_type;
  _z_type z;

   typedef double _dx_type;
  _dx_type dx;

   typedef double _dy_type;
  _dy_type dy;

   typedef double _dz_type;
  _dz_type dz;

   typedef double _roll_type;
  _roll_type roll;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef double _droll_type;
  _droll_type droll;

   typedef double _dpitch_type;
  _dpitch_type dpitch;

   typedef double _dyaw_type;
  _dyaw_type dyaw;

   typedef double _flj_type;
  _flj_type flj;

   typedef double _fltl_type;
  _fltl_type fltl;

   typedef double _flbl_type;
  _flbl_type flbl;

   typedef double _frj_type;
  _frj_type frj;

   typedef double _frtl_type;
  _frtl_type frtl;

   typedef double _frbl_type;
  _frbl_type frbl;

   typedef double _blj_type;
  _blj_type blj;

   typedef double _bltl_type;
  _bltl_type bltl;

   typedef double _blbl_type;
  _blbl_type blbl;

   typedef double _brj_type;
  _brj_type brj;

   typedef double _brtl_type;
  _brtl_type brtl;

   typedef double _brbl_type;
  _brbl_type brbl;

   typedef double _dflj_type;
  _dflj_type dflj;

   typedef double _dfltl_type;
  _dfltl_type dfltl;

   typedef double _dflbl_type;
  _dflbl_type dflbl;

   typedef double _dfrj_type;
  _dfrj_type dfrj;

   typedef double _dfrtl_type;
  _dfrtl_type dfrtl;

   typedef double _dfrbl_type;
  _dfrbl_type dfrbl;

   typedef double _dblj_type;
  _dblj_type dblj;

   typedef double _dbltl_type;
  _dbltl_type dbltl;

   typedef double _dblbl_type;
  _dblbl_type dblbl;

   typedef double _dbrj_type;
  _dbrj_type dbrj;

   typedef double _dbrtl_type;
  _dbrtl_type dbrtl;

   typedef double _dbrbl_type;
  _dbrbl_type dbrbl;





  typedef boost::shared_ptr< ::deeprl::State_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::deeprl::State_<ContainerAllocator> const> ConstPtr;

}; // struct State_

typedef ::deeprl::State_<std::allocator<void> > State;

typedef boost::shared_ptr< ::deeprl::State > StatePtr;
typedef boost::shared_ptr< ::deeprl::State const> StateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::deeprl::State_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::deeprl::State_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace deeprl

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'deeprl': ['/home/vasista/Desktop/quadrupedal_robot/src/deeprl/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::deeprl::State_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::deeprl::State_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::deeprl::State_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::deeprl::State_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::deeprl::State_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::deeprl::State_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::deeprl::State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "342a3f14758aa4591390d3a42f7f92a4";
  }

  static const char* value(const ::deeprl::State_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x342a3f14758aa459ULL;
  static const uint64_t static_value2 = 0x1390d3a42f7f92a4ULL;
};

template<class ContainerAllocator>
struct DataType< ::deeprl::State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "deeprl/State";
  }

  static const char* value(const ::deeprl::State_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::deeprl::State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
float64 error_dist\n\
float64 error_angle\n\
float64 x\n\
float64 y\n\
float64 z\n\
float64 dx\n\
float64 dy\n\
float64 dz\n\
float64 roll\n\
float64 pitch\n\
float64 yaw\n\
float64 droll\n\
float64 dpitch\n\
float64 dyaw\n\
float64 flj\n\
float64 fltl\n\
float64 flbl\n\
float64 frj\n\
float64 frtl\n\
float64 frbl\n\
float64 blj\n\
float64 bltl\n\
float64 blbl\n\
float64 brj\n\
float64 brtl\n\
float64 brbl\n\
float64 dflj\n\
float64 dfltl\n\
float64 dflbl\n\
float64 dfrj\n\
float64 dfrtl\n\
float64 dfrbl\n\
float64 dblj\n\
float64 dbltl\n\
float64 dblbl\n\
float64 dbrj\n\
float64 dbrtl\n\
float64 dbrbl\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::deeprl::State_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::deeprl::State_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.error_dist);
      stream.next(m.error_angle);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.dx);
      stream.next(m.dy);
      stream.next(m.dz);
      stream.next(m.roll);
      stream.next(m.pitch);
      stream.next(m.yaw);
      stream.next(m.droll);
      stream.next(m.dpitch);
      stream.next(m.dyaw);
      stream.next(m.flj);
      stream.next(m.fltl);
      stream.next(m.flbl);
      stream.next(m.frj);
      stream.next(m.frtl);
      stream.next(m.frbl);
      stream.next(m.blj);
      stream.next(m.bltl);
      stream.next(m.blbl);
      stream.next(m.brj);
      stream.next(m.brtl);
      stream.next(m.brbl);
      stream.next(m.dflj);
      stream.next(m.dfltl);
      stream.next(m.dflbl);
      stream.next(m.dfrj);
      stream.next(m.dfrtl);
      stream.next(m.dfrbl);
      stream.next(m.dblj);
      stream.next(m.dbltl);
      stream.next(m.dblbl);
      stream.next(m.dbrj);
      stream.next(m.dbrtl);
      stream.next(m.dbrbl);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct State_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::deeprl::State_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::deeprl::State_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "error_dist: ";
    Printer<double>::stream(s, indent + "  ", v.error_dist);
    s << indent << "error_angle: ";
    Printer<double>::stream(s, indent + "  ", v.error_angle);
    s << indent << "x: ";
    Printer<double>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<double>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<double>::stream(s, indent + "  ", v.z);
    s << indent << "dx: ";
    Printer<double>::stream(s, indent + "  ", v.dx);
    s << indent << "dy: ";
    Printer<double>::stream(s, indent + "  ", v.dy);
    s << indent << "dz: ";
    Printer<double>::stream(s, indent + "  ", v.dz);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "droll: ";
    Printer<double>::stream(s, indent + "  ", v.droll);
    s << indent << "dpitch: ";
    Printer<double>::stream(s, indent + "  ", v.dpitch);
    s << indent << "dyaw: ";
    Printer<double>::stream(s, indent + "  ", v.dyaw);
    s << indent << "flj: ";
    Printer<double>::stream(s, indent + "  ", v.flj);
    s << indent << "fltl: ";
    Printer<double>::stream(s, indent + "  ", v.fltl);
    s << indent << "flbl: ";
    Printer<double>::stream(s, indent + "  ", v.flbl);
    s << indent << "frj: ";
    Printer<double>::stream(s, indent + "  ", v.frj);
    s << indent << "frtl: ";
    Printer<double>::stream(s, indent + "  ", v.frtl);
    s << indent << "frbl: ";
    Printer<double>::stream(s, indent + "  ", v.frbl);
    s << indent << "blj: ";
    Printer<double>::stream(s, indent + "  ", v.blj);
    s << indent << "bltl: ";
    Printer<double>::stream(s, indent + "  ", v.bltl);
    s << indent << "blbl: ";
    Printer<double>::stream(s, indent + "  ", v.blbl);
    s << indent << "brj: ";
    Printer<double>::stream(s, indent + "  ", v.brj);
    s << indent << "brtl: ";
    Printer<double>::stream(s, indent + "  ", v.brtl);
    s << indent << "brbl: ";
    Printer<double>::stream(s, indent + "  ", v.brbl);
    s << indent << "dflj: ";
    Printer<double>::stream(s, indent + "  ", v.dflj);
    s << indent << "dfltl: ";
    Printer<double>::stream(s, indent + "  ", v.dfltl);
    s << indent << "dflbl: ";
    Printer<double>::stream(s, indent + "  ", v.dflbl);
    s << indent << "dfrj: ";
    Printer<double>::stream(s, indent + "  ", v.dfrj);
    s << indent << "dfrtl: ";
    Printer<double>::stream(s, indent + "  ", v.dfrtl);
    s << indent << "dfrbl: ";
    Printer<double>::stream(s, indent + "  ", v.dfrbl);
    s << indent << "dblj: ";
    Printer<double>::stream(s, indent + "  ", v.dblj);
    s << indent << "dbltl: ";
    Printer<double>::stream(s, indent + "  ", v.dbltl);
    s << indent << "dblbl: ";
    Printer<double>::stream(s, indent + "  ", v.dblbl);
    s << indent << "dbrj: ";
    Printer<double>::stream(s, indent + "  ", v.dbrj);
    s << indent << "dbrtl: ";
    Printer<double>::stream(s, indent + "  ", v.dbrtl);
    s << indent << "dbrbl: ";
    Printer<double>::stream(s, indent + "  ", v.dbrbl);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DEEPRL_MESSAGE_STATE_H
